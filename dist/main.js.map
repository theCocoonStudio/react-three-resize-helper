{"mappings":"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","sources":["src/index.js","src/components/ResizeHelper.js"],"sourcesContent":["import { useResizeHelper } from \"./components/ResizeHelper\";\nexports.useResizeHelper = useResizeHelper;\n","import { useEffect, useState } from \"react\";\nimport { Box3, MathUtils } from \"three\";\n\nconst handleResize = (ref, options, camera) => {\n  const _ref = ref;\n  const _options = options;\n  const _camera = camera;\n  //calculate returned objected\n  const _size = new Box3().setFromObject(_ref.current);\n  const _vFOV = MathUtils.degToRad(_camera.fov);\n  const _height =\n    2 *\n    Math.tan(_vFOV / 2) *\n    Math.abs(_ref.current.position.z - _camera.position.z); // visible height\n  const _width = _height * _camera.aspect;\n  const _returned = {\n    objMin: _size.min,\n    objMax: _size.max,\n    visWidth: _width,\n    visHeight: _height,\n    aspect: _camera.aspect,\n  };\n  // end calculation\n\n  const _aspect = _camera.aspect;\n  if (_options) {\n    let {\n      breakpoints,\n      positions,\n      rotations,\n      scales,\n      fovs,\n      camZs,\n      useMin,\n      setFunc,\n    } = _options;\n\n    //basic validation\n    if (!Array.isArray(breakpoints)) {\n      throw new TypeError(\n        \"Options requires a breakpoints key referencing a breakpoint array. \",\n        \"ResizeHelper.js\",\n        11,\n      );\n    }\n    if (positions && !Array.isArray(positions)) {\n      throw new TypeError(\n        \"Optional positions key must reference an array.\",\n        \"ResizeHelper.js\",\n        18,\n      );\n    }\n    if (rotations && !Array.isArray(rotations)) {\n      throw new TypeError(\n        \"Optional rotations key must reference an array.\",\n        \"ResizeHelper.js\",\n        25,\n      );\n    }\n    if (scales && !Array.isArray(scales)) {\n      throw new TypeError(\n        \"Optional scales key must reference an array.\",\n        \"ResizeHelper.js\",\n        32,\n      );\n    }\n    if (fovs && !Array.isArray(fovs)) {\n      throw new TypeError(\n        \"Optional fovs key must reference an array.\",\n        \"ResizeHelper.js\",\n        39,\n      );\n    }\n    if (camZs && !Array.isArray(camZs)) {\n      throw new TypeError(\n        \"Optional camZs key must reference an array.\",\n        \"ResizeHelper.js\",\n        46,\n      );\n    }\n    // end validation\n    /*insert current _aspect in the sorted breakpoint array and sort*/\n    breakpoints.push(_aspect);\n    breakpoints.sort();\n    const index = breakpoints.indexOf(_aspect);\n\n    /* find the array index for the changes to implement. Enforce correct breakpoints if aspect exactly matches a breakpoint */\n    let actionIndex = index;\n    /*if usemin, if index is not last, check if entry is not equal to the next entry; if it is you have to use index + 1*/\n    if (useMin && index != breakpoints.length - 1) {\n      actionIndex =\n        breakpoints[index] === breakpoints[index + 1] ? index + 1 : index;\n    }\n\n    /* apply the changes */\n\n    if (positions && positions[actionIndex]) {\n      if (typeof positions[actionIndex] === \"function\") {\n        const pos = positions[actionIndex](_returned, _options.functionScope);\n        _ref.current.position.x = pos[0];\n        _ref.current.position.y = pos[1];\n        _ref.current.position.z = pos[2];\n      } else {\n        if (\n          typeof positions[actionIndex][0] != \"undefined\" &&\n          positions[actionIndex][0] != null\n        ) {\n          _ref.current.position.x = positions[actionIndex][0];\n        }\n        if (\n          typeof positions[actionIndex][1] != \"undefined\" &&\n          positions[actionIndex][1] != null\n        ) {\n          _ref.current.position.y = positions[actionIndex][1];\n        }\n        if (\n          typeof positions[actionIndex][2] != \"undefined\" &&\n          positions[actionIndex][2] != null\n        ) {\n          _ref.current.position.z = positions[actionIndex][2];\n        }\n      }\n    }\n\n    if (rotations && rotations[actionIndex]) {\n      if (typeof rotations[actionIndex] === \"function\") {\n        const rot = rotations[actionIndex](_returned, _options.functionScope);\n        _ref.current.rotation.x = rot[0];\n        _ref.current.rotation.y = rot[1];\n        _ref.current.rotation.z = rot[2];\n      } else {\n        if (\n          typeof rotations[actionIndex][0] != \"undefined\" &&\n          rotations[actionIndex][0] != null\n        ) {\n          _ref.current.rotation.x = rotations[actionIndex][0];\n        }\n        if (\n          typeof rotations[actionIndex][1] != \"undefined\" &&\n          rotations[actionIndex][1] != null\n        ) {\n          _ref.current.rotation.y = rotations[actionIndex][1];\n        }\n        if (\n          typeof rotations[actionIndex][2] != \"undefined\" &&\n          rotations[actionIndex][2] != null\n        ) {\n          _ref.current.rotation.z = rotations[actionIndex][2];\n        }\n      }\n    }\n\n    if (scales && scales[actionIndex]) {\n      if (typeof scales[actionIndex] === \"function\") {\n        const sca = scales[actionIndex](_returned, _options.functionScope);\n        _ref.current.scale.x = sca[0];\n        _ref.current.scale.y = sca[1];\n        _ref.current.scale.z = sca[2];\n      } else {\n        if (\n          typeof scales[actionIndex][0] != \"undefined\" &&\n          scales[actionIndex][0] != null\n        ) {\n          _ref.current.scale.x = scales[actionIndex][0];\n        }\n        if (\n          typeof scales[actionIndex][1] != \"undefined\" &&\n          scales[actionIndex][1] != null\n        ) {\n          _ref.current.scale.y = scales[actionIndex][1];\n        }\n        if (\n          typeof scales[actionIndex][2] != \"undefined\" &&\n          scales[actionIndex][2] != null\n        ) {\n          _ref.current.scale.z = scales[actionIndex][2];\n        }\n      }\n    }\n    if (fovs && fovs[actionIndex]) {\n      _camera.fov =\n        typeof fovs[actionIndex] === \"function\"\n          ? fovs[actionIndex](_returned, _options.functionScope)\n          : fovs[actionIndex];\n      _camera.updateProjectionMatrix();\n    }\n    if (camZs && camZs[actionIndex]) {\n      _camera.position.z =\n        typeof camZs[actionIndex] === \"function\"\n          ? camZs[actionIndex](_returned, _options.functionScope)\n          : camZs[actionIndex];\n      _camera.updateProjectionMatrix();\n    }\n\n    if (setFunc && setFunc[actionIndex]) {\n      setFunc[actionIndex](_returned, _options.functionScope);\n    }\n  }\n  return _returned;\n};\n\nexport const useResizeHelper = (ref, camera, options) => {\n  let [dimensions, setDimensions] = useState(null);\n\n  useEffect(() => {\n    setDimensions(handleResize(ref, options, camera));\n  }, [camera.aspect, ref, camera, ref.current]);\n\n  return dimensions;\n};\n"],"names":[],"version":3,"file":"main.js.map"}